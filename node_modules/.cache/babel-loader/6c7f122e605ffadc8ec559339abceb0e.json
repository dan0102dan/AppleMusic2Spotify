{"ast":null,"code":"import Papa from 'papaparse';\nimport axios from 'axios';\nimport axiosCancel from 'axios-cancel';\nimport { findIndex } from 'lodash';\nimport { API_URL } from '../constants/Constants';\nimport { getToken } from './AuthService';\naxiosCancel(axios);\nexport default class AppleMusicPlaylist {\n  constructor(settings) {\n    this._playlist = [];\n    this.changeCallbacks = [];\n    this.spotifyStatus = null;\n    this.settings = {\n      searchFormat: '{name} {artist}',\n      ...settings\n    };\n  }\n\n  setPlaylist(playlist) {\n    let parsed = Papa.parse(playlist, {\n      header: true\n    });\n\n    if (parsed.errors.length && !parsed.data.length) {\n      throw new Error('Couldn\\'t parse the playlist.');\n    }\n\n    parsed.data.pop();\n\n    for (let index = 0; parsed.data.length > index; index++) {\n      const track = parsed.data[index],\n            keys = Object.keys(track);\n\n      if (!keys.includes('Name') || !keys.includes('Artist') || !keys.includes('Album')) {\n        throw new Error('Playlist is not a valid apple music playlist.');\n      }\n\n      this._playlist.push({\n        index,\n        name: track.Name,\n        artist: track.Artist,\n        album: track.Album,\n        composer: track.Composer,\n        discCount: track['Disc Count'],\n        discNumber: track['Disc Number'],\n        genre: track.Genre,\n        trackCount: track['Track Count'],\n        trackNumber: track['Track Number'],\n        year: track.Year,\n        spotifyStatus: 'pending',\n        spotifyResults: null,\n        spotifySelected: null\n      });\n    }\n  }\n\n  filter(indexes) {\n    const newPlaylist = [];\n\n    for (let i = 0; indexes.length > i; i++) {\n      newPlaylist.push(this._playlist[indexes[i]]);\n    }\n\n    this._playlist = newPlaylist;\n  }\n\n  get playlist() {\n    return this._playlist;\n  }\n\n  getPlaylist(status) {\n    const output = [];\n\n    for (let index = 0; this._playlist.length > index; index++) {\n      if (this._playlist[index].spotifyStatus === status) {\n        output.push(this._playlist[index]);\n      }\n    }\n\n    return output;\n  }\n\n  setSpotifySelected(trackIndex, id) {\n    const track = this._playlist[trackIndex];\n    let selectedIndex = findIndex(track.spotifyResults, {\n      id\n    });\n    track.spotifySelected = track.spotifyResults[selectedIndex];\n    this.triggerChange();\n    return this;\n  }\n\n  setSpotifyStatus(status) {\n    this.spotifyStatus = status;\n    this.triggerChange();\n    return this;\n  }\n\n  onChange(cb) {\n    this.changeCallbacks.push(cb);\n  }\n\n  triggerChange() {\n    for (let index = 0; this.changeCallbacks.length > index; index++) {\n      this.changeCallbacks[index]();\n    }\n  }\n\n  startSearch() {\n    this.searchTimeout = setTimeout(this._search.bind(this), 1);\n  }\n\n  searchKeyword(track) {\n    const placeholders = ['{name}', '{artist}', '{album}', '{composer}', '{discCount}', '{discNumber}', '{genre}', '{trackCount}', '{trackNumber}', '{year}'];\n    let keyword = this.settings.searchFormat;\n\n    for (let index = 0; placeholders.length > index; index++) {\n      keyword = keyword.replace(placeholders[index], track[placeholders[index].slice(1, -1)]);\n    }\n\n    return keyword;\n  }\n\n  option(key, value) {\n    this.settings[key] = value;\n    return this;\n  }\n\n  _search() {\n    let track;\n\n    for (let index = 0; this._playlist.length > index; index++) {\n      if (this._playlist[index].spotifyStatus === 'pending') {\n        track = this._playlist[index];\n        break;\n      }\n    }\n\n    if (!track) {\n      this.spotifyStatus = 'searchComplete';\n      this.triggerChange();\n      return;\n    }\n\n    this.spotifyStatus = 'searching';\n    track.spotifyStatus = 'searching';\n    this.triggerChange();\n    axios.get(`${API_URL}/v1/search`, {\n      requestId: 'search',\n      headers: {\n        Authorization: `Bearer ${getToken()}`\n      },\n      params: {\n        type: 'track',\n        q: this.searchKeyword(track),\n        limit: 10\n      }\n    }).then(res => {\n      track.spotifyStatus = res.data.tracks.total === 0 ? 'noResult' : 'withResult';\n      track.spotifyResults = res.data.tracks.items;\n      if (res.data.tracks.total) track.spotifySelected = res.data.tracks.items[0];\n      this.searchTimeout = setTimeout(this._search.bind(this), 10);\n    }).catch(error => {\n      track.spotifyStatus = axios.isCancel(error) ? 'pending' : 'failed';\n    }).finally(() => {\n      this.triggerChange();\n    });\n  }\n\n  pauseSearch() {\n    this.spotifyStatus = 'paused';\n    clearTimeout(this.searchTimeout);\n    this.triggerChange();\n    axios.cancel('search');\n  }\n\n}","map":{"version":3,"sources":["/Users/daniildavydov/Downloads/applemusic2spotify/src/services/AppleMusicPlaylist.js"],"names":["Papa","axios","axiosCancel","findIndex","API_URL","getToken","AppleMusicPlaylist","constructor","settings","_playlist","changeCallbacks","spotifyStatus","searchFormat","setPlaylist","playlist","parsed","parse","header","errors","length","data","Error","pop","index","track","keys","Object","includes","push","name","Name","artist","Artist","album","Album","composer","Composer","discCount","discNumber","genre","Genre","trackCount","trackNumber","year","Year","spotifyResults","spotifySelected","filter","indexes","newPlaylist","i","getPlaylist","status","output","setSpotifySelected","trackIndex","id","selectedIndex","triggerChange","setSpotifyStatus","onChange","cb","startSearch","searchTimeout","setTimeout","_search","bind","searchKeyword","placeholders","keyword","replace","slice","option","key","value","get","requestId","headers","Authorization","params","type","q","limit","then","res","tracks","total","items","catch","error","isCancel","finally","pauseSearch","clearTimeout","cancel"],"mappings":"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","sourcesContent":["import Papa from 'papaparse';\nimport axios from 'axios';\nimport axiosCancel from 'axios-cancel';\nimport { findIndex } from 'lodash';\n\nimport { API_URL } from '../constants/Constants';\nimport { getToken } from './AuthService';\n\naxiosCancel(axios);\n\nexport default class AppleMusicPlaylist {\n\n  constructor (settings) {\n    this._playlist = [];\n    this.changeCallbacks = [];\n    this.spotifyStatus = null;\n    this.settings = {\n      searchFormat: '{name} {artist}',\n      ...settings\n    };\n  }\n\n  setPlaylist (playlist) {\n    let parsed = Papa.parse(playlist, {\n      header: true\n    });\n    if (parsed.errors.length && !parsed.data.length) {\n      throw new Error('Couldn\\'t parse the playlist.');\n    }\n    parsed.data.pop();\n    for (let index = 0; parsed.data.length > index; index++) {\n      const\n        track = parsed.data[index],\n        keys = Object.keys(track);\n      if (!keys.includes('Name') || !keys.includes('Artist') || !keys.includes('Album')) {\n        throw new Error('Playlist is not a valid apple music playlist.');\n      }\n      this._playlist.push({\n        index,\n        name           : track.Name,\n        artist         : track.Artist,\n        album          : track.Album,\n        composer       : track.Composer,\n        discCount      : track['Disc Count'],\n        discNumber     : track['Disc Number'],\n        genre          : track.Genre,\n        trackCount     : track['Track Count'],\n        trackNumber    : track['Track Number'],\n        year           : track.Year,\n        spotifyStatus  : 'pending',\n        spotifyResults : null,\n        spotifySelected: null\n      });\n    }\n  }\n\n  filter (indexes) {\n    const newPlaylist = [];\n    for (let i = 0; indexes.length > i; i++) {\n      newPlaylist.push(this._playlist[indexes[i]]);\n    }\n    this._playlist = newPlaylist;\n  }\n\n  get playlist () {\n    return this._playlist;\n  }\n\n  getPlaylist (status) {\n    const output = [];\n    for (let index = 0; this._playlist.length > index; index++) {\n      if (this._playlist[index].spotifyStatus === status) {\n        output.push(this._playlist[index]);\n      }\n    }\n    return output;\n  }\n\n  setSpotifySelected (trackIndex, id) {\n    const track = this._playlist[trackIndex];\n    let selectedIndex = findIndex(track.spotifyResults, {id});\n    track.spotifySelected = track.spotifyResults[selectedIndex];\n    this.triggerChange();\n    return this;\n  }\n\n  setSpotifyStatus (status) {\n    this.spotifyStatus = status;\n    this.triggerChange();\n\n    return this;\n  }\n\n  onChange (cb) {\n    this.changeCallbacks.push(cb);\n  }\n\n  triggerChange () {\n    for (let index = 0; this.changeCallbacks.length > index; index++) {\n      this.changeCallbacks[index]();\n    }\n  }\n\n  startSearch () {\n    this.searchTimeout = setTimeout(this._search.bind(this), 1);\n  }\n\n  searchKeyword (track) {\n    const placeholders = ['{name}', '{artist}', '{album}', '{composer}', '{discCount}', '{discNumber}', '{genre}', '{trackCount}', '{trackNumber}', '{year}'];\n    let keyword = this.settings.searchFormat;\n    for (let index = 0; placeholders.length > index; index++) {\n      keyword = keyword.replace(placeholders[index], track[placeholders[index].slice(1, -1)]);\n    }\n    return keyword;\n  }\n\n  option (key, value) {\n    this.settings[key] = value;\n\n    return this;\n  }\n\n  _search () {\n    let track;\n    for (let index = 0; this._playlist.length > index; index++) {\n      if (this._playlist[index].spotifyStatus === 'pending') {\n        track = this._playlist[index];\n        break;\n      }\n    }\n    if (!track) {\n      this.spotifyStatus = 'searchComplete';\n      this.triggerChange();\n      return;\n    }\n    this.spotifyStatus = 'searching';\n    track.spotifyStatus = 'searching';\n    this.triggerChange();\n    axios.get(\n      `${API_URL}/v1/search`,\n      {\n        requestId: 'search',\n        headers  : {\n          Authorization: `Bearer ${getToken()}`\n        },\n        params   : {\n          type : 'track',\n          q    : this.searchKeyword(track),\n          limit: 10\n        }\n      }\n    )\n      .then((res) => {\n        track.spotifyStatus = res.data.tracks.total === 0 ? 'noResult' : 'withResult';\n        track.spotifyResults = res.data.tracks.items;\n        if (res.data.tracks.total)\n          track.spotifySelected = res.data.tracks.items[0];\n        this.searchTimeout = setTimeout(this._search.bind(this), 10);\n      })\n      .catch((error) => {\n        track.spotifyStatus = axios.isCancel(error) ? 'pending' : 'failed';\n      })\n      .finally(() => {\n        this.triggerChange();\n      });\n\n  }\n\n  pauseSearch () {\n    this.spotifyStatus = 'paused';\n    clearTimeout(this.searchTimeout);\n    this.triggerChange();\n    axios.cancel('search');\n  }\n\n}"]},"metadata":{},"sourceType":"module"}